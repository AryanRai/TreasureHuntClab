/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <serial.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "timer_module.h"
#include "led_control.h"
#include "gamestate.h"
// #include <timer_module.h>

/*
#include <serial module header>
        variables
                send_serial_1
                receive_serial_1
#include <scoreboard display module header>
        variables

#include <LED module header>
#include <magnet detector module>
#include <servo module header>
#include <touchpad module header>
#include <trimpot module header>
*/

/*typedef struct{
        int items_found;
        int items_to_find;
        int digs_taken;
        int digs_remaining;
        int peeks_used;
        int game_time_remaining;
        bool game_over;
} GameState;*/
int message_complete = 0;
int touchpad_interrupt = 1;
int last_servo_angle = -1;
int last_servo_selection = -1;

// For Testing ========
char feedback_string[BUFFER];

// For Testing ========

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning \
    "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void) {
  // For Testing =======
  char* command = NULL;
  char* follow = NULL;
  // For Testing =======

  enableUSART1();
  enableUARTInterrupts();
  clear_screen();



  send_string("hello world");
  clear_screen();

  GameState game = {
			.correct_servos = {1}, //do not use servo number 0 3, 4, 6
			.items_found = 0,
			.items_left_to_find = 1,
			.digs_taken = 0,
			.digs_remaining = 1,
			.peeks_used = 0,
			.game_time_remaining = 240,
			.game_over = 0,
			.total_items_to_find = 0
  };

  //Count item numbers
  int count = 0;
  for (int i = 0; i < 6; i++) {
      if (game.correct_servos[i] != 0) {
          count++;
      }
  }
  game.total_items_to_find = count;

  GameTriggers triggers = {
			.touchpad_pressed = -1,
			.magnet1_det = 0,
			.magnet2_det = 0,
			.servo_controlled = -1,
			.servo_angle = 0,
			.trimpot_value = 0,
			.peek_threshold = 10,
			.pending_peek = 0
  };

  send_string("Game Initialised\r\n");
  // print_game_state(game);
  // print_game_triggers(triggers);

  // triggers.touchpad_pressed = touchpad_interrupt;

  // Loop forever
  while (game.game_over == 0) {
    if (message_complete == 1) {
      command = strtok((char*)string, " ");  // load commmand
      follow = strtok(NULL, "");             // load
      //		      message_complete = 0;  // need to reset this for
      //next message
      clear_screen();
    }
    if (command != NULL && message_complete == 1) {
      if (strcmp(command, "touchpad") == 0 && valid_period_check(follow) != 0) {

        sprintf(feedback_string, "Touchpad set to: %s \r\n", follow);
        send_string(feedback_string);
        triggers.touchpad_pressed = atoi(follow);
        memset(feedback_string, 0, BUFFER);
        send_string("Touchpad set to ");
        send_string_buffer(triggers.touchpad_pressed);
        send_string("\r\n");
        //		          print_game_triggers(triggers);
        message_complete = 0;

      } else if (strcmp(command, "servo") == 0 &&
                 valid_period_check(follow) != 0) {

        sprintf(feedback_string, "Servo angle set to: %s \r\n", follow);
        send_string(feedback_string);
        triggers.servo_angle = atoi(follow);
        triggers.trimpot_value = atoi(follow);  // Remove this later
        memset(feedback_string, 0, BUFFER);
        send_string("Servo set to ");
        send_string_buffer(triggers.servo_angle);
        send_string("\r\n\r\n");
        // print_game_triggers(triggers);
        message_complete = 0;

      } else if (strcmp(command, "trimpot") == 0 &&
                 valid_period_check(follow) != 0) {

        sprintf(feedback_string, "Trimpot Value set to: %s \r\n", follow);
        send_string(feedback_string);
        triggers.trimpot_value = atoi(follow);
        memset(feedback_string, 0, BUFFER);
        send_string("Trimpot set to ");
        send_string_buffer(triggers.trimpot_value);
        send_string("\r\n");

        // print_game_triggers(triggers);
        message_complete = 0;

      } else if (strcmp(command, "triggers") == 0){
    	  print_game_triggers(triggers);
    	  message_complete = 0;
      } else if (strcmp(command, "game") == 0){
    	  print_game_state(game);
    	  message_complete = 0;
      } else {
        send_string("Unknown command\r\n");
        message_complete = 0;
      }
      reset_input_buffer();
      command = NULL;
      follow = NULL;
      message_complete = 0;
      memset(feedback_string, 0, BUFFER);
    }

    // Need an interrupt to change triggers.touchpad_pressed = -1 when touchpad
    // is pressed
    if (triggers.touchpad_pressed != -1) {
      // send_string("\n\ntouchpad pressed\r\n");
      triggers.servo_controlled = triggers.touchpad_pressed;
      /*send_string("Touchpad Pressed trigged, Servo being controlled ");
      send_string_buffer(triggers.servo_controlled);
      send_string("\r\n");
      touctriggers.touchpad_pressed = -1;
      */
      // print_game_triggers(triggers);

      if (triggers.servo_controlled != -1) {
    	  if (triggers.servo_controlled != last_servo_selection) {
    	          if(triggers.pending_peek == 1){
    	        	game.peeks_used += 1;
					send_string("New Peek Used\r\n");
					print_game_state(game);
					triggers.pending_peek = 0;
    	          } // Reset peek
    	          triggers.servo_angle = 0;
    	          last_servo_selection = triggers.servo_controlled;
    	      }


          if (triggers.servo_angle != last_servo_angle) {

              // Respond to angle
              if (triggers.servo_angle == 0) {
                  send_string("Door Closed\r\n");


                  if (triggers.pending_peek == 1 && last_servo_selection == triggers.servo_controlled) { // only change peek if dig is not passed
                      game.peeks_used += 1;
                      send_string("New Peek Used\r\n");
                      print_game_state(game);
                      triggers.pending_peek = 0; // Reset peek
                  }
              } else if (triggers.servo_angle > 0 && triggers.servo_angle < triggers.peek_threshold) {
                  send_string("Below Dig Threshold. But above 0. Peek in Progress.\r\n");

                  // Only increment peek count if coming *from* a closed or dig state
                  if (last_servo_angle == 0 && last_servo_selection == triggers.servo_controlled) {
                	  //game.peeks_used += 1;
                      //send_string("New Peek Used\r\n");
                	  //print_game_state(game);
                	  triggers.pending_peek = 1;
                  }

              } else if (triggers.servo_angle >= triggers.peek_threshold) {
                  send_string("Dig Threshold Passed.\r\n");


                  // Only increment dig count if last angle was not already a dig
                  if (last_servo_angle < triggers.peek_threshold && last_servo_selection == triggers.servo_controlled) {
                      game.digs_taken += 1;
                      game.digs_remaining -= 1;
                      if (check_servo_choice(game.correct_servos, triggers.servo_controlled, game.total_items_to_find) == 1) {
                              game.items_found++;
                              game.items_left_to_find--;
                          }
                      send_string("New Dig Used\r\n\r\n");
                      print_game_state(game);
                      send_string("\r\n");

                  }
                  triggers.pending_peek = 0;
              }

              // Update the last angle
              last_servo_angle = triggers.servo_angle;
              last_servo_selection =triggers.servo_controlled;
          }
      }
    }




//    if(check_servo_choice(game.correct_servos, triggers.touchpad_pressed, game.total_items_to_find) == 1){
//         game.items_found++;
//         game.items_left_to_find--;
// 		triggers.servo_controlled = -1; //turn servo control back to off
// //		game.digs_taken = game.digs_taken +1;
// //		game.digs_remaining = game.digs_remaining-1;
//         } else {
//         	triggers.servo_controlled = -1; //turn servo control back to off
// //		game.digs_taken = game.digs_taken +1;
// //		game.digs_remaining = game.digs_remaining-1;
//         }
//




//        send_serial_to_scoreboard;

          /*				while (triggers.servo_angle >
             triggers.peek_threshold){ if(triggers.servo_angle > 0 &&
             triggers.servo_angle < 90){ // Need to close door to go on

                                                          send_string("Door
             Still Open. Close to Go On");
                                                          //send_trimpot_val(triggers.servo_controlled,
             trimpot_servo_range());
                                                          //receive_trimpot_value();
                                                          //trimpot_servo_range();
                                                          }
                                                  }*/


        // Reset touchpad and servo
        /*
                                        triggers.servo_controlled = -1;  //
           Reset control flag send_string("\n\nTouchpad reset to -1\r\n");
                                        triggers.touchpad_pressed = -1; //turn
           touchpad flag to off
        */
    /*

    if(check_servo_choice(game.correct_servos, triggers.touchpad_pressed,
game.total_items_to_find) == 1){ game.items_found = game.items_found+1;
            game.items_left_to_find = game.items_left_to_find -1;
            game.digstouc_taken = game.digs_taken +1;
            game.digs_remaining = game.digs_remaining-1;
    } else {
            game.digs_taken = game.digs_taken +1;
            game.digs_remaining = game.digs_remaining-1;
    }
    send_serial_to_scoreboard;

    triggers.servo_controlled != -1 //turn servo control back to off
}



    if(game.items_left_to_find == 0 || game.digs_remaining == 0 ||
game.time_remaining == 0;){ game.game_over = 1;
    }
*/
    if(game.items_left_to_find == 0 || game.digs_remaining == 0 ||
    game.game_time_remaining == 0){
    	game.game_over = 1;
    	print_game_state(game);
    	send_string("Game Over\r\n");

    	if(game.digs_remaining == 0 & game.items_left_to_find != 0 ){
    		send_string("You used all your digs without finding the treasure, you lose.\r\n");
    	} else if(game.game_time_remaining == 0){
    		send_string("You ran out of time to find the treasure, you lose.\r\n");
    	} else {
    		send_string("You found all the treasure, you win!\r\n");

    		enableLEDs();
    		set_timer2(1000*8);
    		timer2_set_callback(LEDflash);
    		enableTimer2();  // enable timer

    	}
    }
}
  return 0;
}
