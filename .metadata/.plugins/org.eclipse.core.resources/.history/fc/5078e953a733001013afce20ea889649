/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdbool.h>
#include <serial.h>
#include <stdlib.h>
#include "gamestate.h"
//#include <timer_module.h>

/*
#include <serial module header>
	variables
		send_serial_1
		receive_serial_1
#include <scoreboard display module header>
	variables

#include <LED module header>
#include <magnet detector module>
#include <touchpad module header>
#include <servo module header>
#include <trimpot module header>
*/

/*typedef struct{
	int items_found;
	int items_to_find;
	int digs_taken;
	int digs_remaining;
	int peeks_used;
	int game_time_remaining;
	bool game_over;
} GameState;*/
int message_complete = 0;
int touchpad_interrupt = 1;

// For Testing ========
char feedback_string[BUFFER];

// For Testing ========


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void){
	//For Testing =======
	char* command = NULL;
	char* follow = NULL;
	//For Testing =======

	enableUSART1();
	enableUARTInterrupts();
	clear_screen();

	send_string("hello world");
	clear_screen();

	GameState game = {
			.correct_servos = {1,3,4,6},
			.items_found = 0,
			.items_left_to_find = 4,
			.digs_taken = 0,
			.digs_remaining = 4,
			.peeks_used = 0,
			.game_time_remaining = 240,
			.game_over = 0,
			.total_items_to_find = 0
	};

	game.total_items_to_find = sizeof( game.correct_servos) / sizeof(game.correct_servos[0]);

	GameTriggers triggers = {
		.touchpad_pressed = -1,
		.magnet1_det = 0,
		.magnet2_det = 0,
		.servo_controlled = -1,
		.servo_angle = 0,
		.peek_threshold = 10
	};



	print_game_state(game);
	print_game_triggers(triggers);



	//triggers.touchpad_pressed = touchpad_interrupt;

     //Loop forever
	while(game.game_over == 0){

		if (message_complete == 1) {
		      command = strtok((char*)string, " ");  // load commmand
		      follow = strtok(NULL, "");            // load
//		      message_complete = 0;  // need to reset this for next message
		      clear_screen();
		    }
		if (command != NULL && message_complete == 1) {
		      if (strcmp(command, "touchpad") == 0 && valid_period_check(follow) != 0) {
		    	  sprintf(feedback_string, "Touchpad set to: %s \r\n", follow);
		          send_string(feedback_string);
		          triggers.touchpad_pressed = atoi(follow);
		          memset(feedback_string, 0, BUFFER);
		          print_game_triggers(triggers);
		          message_complete = 0;
		} else if (strcmp(command, "servo") == 0 && valid_period_check(follow) != 0) {
					  sprintf(feedback_string, "Servo angle set to: %s \r\n", follow);
					  send_string(feedback_string);
					  triggers.servo_angle = atoi(follow);
					  memset(feedback_string, 0, BUFFER);
					  print_game_triggers(triggers);
					  message_complete = 0;
			} else {
		        send_string("Unknown command\r\n");
		reset_input_buffer();  // reset string
		command = NULL;
		follow = NULL;
	}
	}

     /*
		// Need an interrupt to change triggers.touchpad_pressed = -1 when touchpad is pressed
		while( triggers.touchpad_pressed != -1) {
			send_string("touchpad pressed\r\n");
			triggers.servo_controlled = touchpad_pressed
			triggers.touchpad_pressed = -1; //turn touchpad flag to off
					}
				}

			while(triggers.servo_controlled != -1) {
				receive_trimpot_value(); function to retrieve trimpot value
				trimpot_servo_range(); function to turn trimpot variable into value between servo motor fully open/fully closed range

				if(trimpot_servo_range() < peek_threshold{

				//instigate peak which opens door certain amount

					while(trimpot_servo_range >0 && trimpot_servo_range < peek_threshold){
					send_trimpot_val(triggers.servo_controlled, trimpot_servo_range());  // function to send trimpot value to SPECIFIC servo motor
					receive_trimpot_value()
					trimpot_servo_range();

					}
				game.peaks_used = game.peaks_used+1


				} else if(trimpot_servo_range()> peek_threshold{
					while(trimpot_servo_range > 0 && trimpot_servo_range < max(trimpot_servo_range()){ // Need to close door to go on
						send_trimpot_val(triggers.servo_controlled, trimpot_servo_range());
						receive_trimpot_value();
						trimpot_servo_range();
						}
					}





				if(check_servo_choice(game.correct_servos, triggers.touchpad_pressed, game.total_items_to_find) == 1){
					game.items_found = game.items_found+1;
					game.items_left_to_find = game.items_left_to_find -1;
					game.digs_taken = game.digs_taken +1;
					game.digs_remaining = game.digs_remaining-1;
				} else {
					game.digs_taken = game.digs_taken +1;
					game.digs_remaining = game.digs_remaining-1;
				}
				send_serial_to_scoreboard;

				triggers.servo_controlled != -1 //turn servo control back to off
			}



				if(game.items_left_to_find == 0 || game.digs_remaining == 0 || game.time_remaining == 0;){
					game.game_over = 1;
				}
*/

	return 0;
}

