








*Computer Interface*

*Scoreboard Display:*

    Time Remaining

    Digs Remaining

    Items Remaining To find (Treasure 1/Treasure 2)

    Items Found

    **Stretch Goal:** “Peek” function. Allow user to select touch pad to dig in a location, but take small amount of slow rotation of trimpot to raise lid 10 degrees to allow a peak that does not count as a dig. If peek is had and decided not to dig then “close” door with trimpot and continue searching. Once new touchpad is selected for a following dig the logic resets to the new location as the “peek/dig” location.

    If person does not use the trimpot slowly then it will not peak/ the door will open fully and a dig will be counted.

    **Stretch Goal:** Power Meter/Power Gauge to “dig”  [https://www.youtube.com/watch?v=YL4XGAPV5GY](https://www.youtube.com/watch?v=YL4XGAPV5GY)

    [https://youtu.be/JXunRTGTKBY?si=f8ip4NFWSw_m5nnz&t=19](https://youtu.be/JXunRTGTKBY?si=f8ip4NFWSw_m5nnz&t=24)

    Addition to Peek function is a power meter function that requires the player to rotate the trimpot to hit a specific power meter gauge level for a successful dig. Could have the power meter bar need to be hit 3 times for a successful dig with the required level slightly different each time. This could still work with a peak function

*Physical Items*

    2xLED On Board/Wand to show presence of Treasure A/Treasure B (small magnets or large magnets)

    Potentiometer for digging

    Start Button?

*Software Modules:*

    **Game Logic/Status Module** (Game Timer/Items Found/ Items Remaining/Digs/Remaining)

    **Serial Module**

    **Scoreboard Display Module**

    **LED Module**

    **Magnet Detector Module**

    **Touchpad Module**

    **Servo Module**

    **Trimpot (Dig) Module**

*Logic:*

    *Touchpad Module:*

        Game Start signaled

    *Game Logic/Status Module:*

        Game Timer Start

        Game Timer loop w/ interrupt for Game Finish

    *Scoreboard Module:*

        Display timer

        Display x items to find

        Display y items found

        Display n digs remaining

    *Magnet Detector Module:*

        Return Magnet Detection Value

    *LED Module:*

        Receive Magnet Detection Value

            *If in Treasure1 Range:*

                Turn on Led on LED1 on Magnet Detector Value Threshold Reached

            *If in Treasure2 Range:*

                Turn on Led on LED1 on Magnet Detector Value Threshold Reached

            *If in neither*

                Turn off LEDs

    *Touchpad Module:*

        Return value to *Game Logic/Status Module*

    *Trimpot Module:*

        Return value to *Game Logic/Status Module*

    *Game Logic/Status Module:*

    *If Touchpad value = 1:*

        Check trimpot value meets required threshold for successful dig

        *If yes:*

            Signal servo module to open servo

            *Servo module:*

                Open trapdoor

        *If no, if trimpot value meets required threshold for “peek” signal:*

            *Servo module:*

                Open trapdoor “peek”

        *If no:*

            continue to monitor trimpot value.

    *If Touchpad value = 0:*

        continue game loop

    *Game Logic/Status Module:*

        Check that servo opened was correct item

            *If correct:*

                Set x items to find to x-1

                Set y items found to y+1

                Set n digs remaining to n -1

                Send to **Scoreboard Display Module**

            *If incorrect:*

                Set n digs remaining to n -1

                Send to **Scoreboard Display Module**

        Check n digs remaining >0

            *If yes:*

            continue game loop

            *If no:*

            Send to **Scoreboard Display Module:**

            Finish screen.


















            implementation



            main.c


            /**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <serial.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#include "gamestate.h"
// #include <timer_module.h>

/*
#include <serial module header>
        variables
                send_serial_1
                receive_serial_1
#include <scoreboard display module header>
        variables

#include <LED module header>
#include <magnet detector module>
#include <servo module header>
#include <touchpad module header>
#include <trimpot module header>
*/

/*typedef struct{
        int items_found;
        int items_to_find;
        int digs_taken;
        int digs_remaining;
        int peeks_used;
        int game_time_remaining;
        bool game_over;
} GameState;*/
int message_complete = 0;
int touchpad_interrupt = 1;
int last_servo_angle = -1;
int last_servo_selection = -1;

// For Testing ========
char feedback_string[BUFFER];

// For Testing ========

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning \
    "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void) {
  // For Testing =======
  char* command = NULL;
  char* follow = NULL;
  // For Testing =======

  enableUSART1();
  enableUARTInterrupts();
  clear_screen();

  send_string("hello world");
  clear_screen();

  GameState game = {
			.correct_servos = {1, 3, 4, 6}, //do not use servo number 0
			.items_found = 0,
			.items_left_to_find = 4,
			.digs_taken = 0,
			.digs_remaining = 4,
			.peeks_used = 0,
			.game_time_remaining = 240,
			.game_over = 0,
			.total_items_to_find = 0
  };

  //Count item numbers
  int count = 0;
  for (int i = 0; i < 6; i++) {
      if (game.correct_servos[i] != 0) {
          count++;
      }
  }
  game.total_items_to_find = count;

  GameTriggers triggers = {
			.touchpad_pressed = -1,
			.magnet1_det = 0,
			.magnet2_det = 0,
			.servo_controlled = -1,
			.servo_angle = 0,
			.trimpot_value = 0,
			.peek_threshold = 10,
			.pending_peek = 0
  };

  send_string("Game Initialised\r\n");
  // print_game_state(game);
  // print_game_triggers(triggers);

  // triggers.touchpad_pressed = touchpad_interrupt;

  // Loop forever
  while (game.game_over == 0) {
    if (message_complete == 1) {
      command = strtok((char*)string, " ");  // load commmand
      follow = strtok(NULL, "");             // load
      //		      message_complete = 0;  // need to reset this for
      //next message
      clear_screen();
    }
    if (command != NULL && message_complete == 1) {
      if (strcmp(command, "touchpad") == 0 && valid_period_check(follow) != 0) {

        sprintf(feedback_string, "Touchpad set to: %s \r\n", follow);
        send_string(feedback_string);
        triggers.touchpad_pressed = atoi(follow);
        memset(feedback_string, 0, BUFFER);
        send_string("Touchpad set to ");
        send_string_buffer(triggers.touchpad_pressed);
        send_string("\r\n");
        //		          print_game_triggers(triggers);
        message_complete = 0;

      } else if (strcmp(command, "servo") == 0 &&
                 valid_period_check(follow) != 0) {

        sprintf(feedback_string, "Servo angle set to: %s \r\n", follow);
        send_string(feedback_string);
        triggers.servo_angle = atoi(follow);
        triggers.trimpot_value = atoi(follow);  // Remove this later
        memset(feedback_string, 0, BUFFER);
        send_string("Servo set to ");
        send_string_buffer(triggers.servo_angle);
        send_string("\r\n");
        // print_game_triggers(triggers);
        message_complete = 0;

      } else if (strcmp(command, "trimpot") == 0 &&
                 valid_period_check(follow) != 0) {

        sprintf(feedback_string, "Trimpot Value set to: %s \r\n", follow);
        send_string(feedback_string);
        triggers.trimpot_value = atoi(follow);
        memset(feedback_string, 0, BUFFER);
        send_string("Trimpot set to ");
        send_string_buffer(triggers.trimpot_value);
        send_string("\r\n");

        // print_game_triggers(triggers);
        message_complete = 0;

      } else if (strcmp(command, "triggers") == 0){
    	  print_game_triggers(triggers);
    	  message_complete = 0;
      } else if (strcmp(command, "game") == 0){
    	  print_game_state(game);
    	  message_complete = 0;
      } else {
        send_string("Unknown command\r\n");
        message_complete = 0;
      }
      reset_input_buffer();
      command = NULL;
      follow = NULL;
      message_complete = 0;
      memset(feedback_string, 0, BUFFER);
    }

    // Need an interrupt to change triggers.touchpad_pressed = -1 when touchpad
    // is pressed
    if (triggers.touchpad_pressed != -1) {
      // send_string("\n\ntouchpad pressed\r\n");
      triggers.servo_controlled = triggers.touchpad_pressed;
      /*send_string("Touchpad Pressed trigged, Servo being controlled ");
      send_string_buffer(triggers.servo_controlled);
      send_string("\r\n");
      touctriggers.touchpad_pressed = -1;
      */
      // print_game_triggers(triggers);

      if (triggers.servo_controlled != -1) {
    	  if (triggers.servo_controlled != last_servo_selection) {
    	          if(triggers.pending_peek == 1){
    	        	game.peeks_used += 1;
					send_string("New Peek Used\r\n");
					print_game_state(game);
					triggers.pending_peek = 0;
    	          } // Reset peek
    	          triggers.servo_angle = 0;
    	          last_servo_selection = triggers.servo_controlled;
    	      }


          if (triggers.servo_angle != last_servo_angle) {

              // Respond to angle
              if (triggers.servo_angle == 0) {
                  send_string("Door Closed\r\n");


                  if (triggers.pending_peek == 1 && last_servo_selection == triggers.servo_controlled) { // only change peek if dig is not passed
                      game.peeks_used += 1;
                      send_string("New Peek Used\r\n");
                      print_game_state(game);
                      triggers.pending_peek = 0; // Reset peek
                  }
              } else if (triggers.servo_angle > 0 && triggers.servo_angle < triggers.peek_threshold) {
                  send_string("Below Dig Threshold. But above 0. Peek in Progress.\r\n");

                  // Only increment peek count if coming *from* a closed or dig state
                  if (last_servo_angle == 0 && last_servo_selection == triggers.servo_controlled) {
                	  //game.peeks_used += 1;
                      //send_string("New Peek Used\r\n");
                	  //print_game_state(game);
                	  triggers.pending_peek = 1;
                  }

              } else if (triggers.servo_angle >= triggers.peek_threshold) {
                  send_string("Dig Threshold Passed.\r\n");


                  // Only increment dig count if last angle was not already a dig
                  if (last_servo_angle < triggers.peek_threshold && last_servo_selection == triggers.servo_controlled) {
                      game.digs_taken += 1;
                      if (check_servo_choice(game.correct_servos, triggers.servo_controlled, game.total_items_to_find) == 1) {
                              game.items_found++;
                              game.items_left_to_find--;
                          }
                      send_string("New Dig Used\r\n");
                      print_game_state(game);

                  }
                  triggers.pending_peek = 0;
              }

              // Update the last angle
              last_servo_angle = triggers.servo_angle;
              last_servo_selection =triggers.servo_controlled;
          }
      }
    }




//    if(check_servo_choice(game.correct_servos, triggers.touchpad_pressed, game.total_items_to_find) == 1){
//         game.items_found++;
//         game.items_left_to_find--;
// 		triggers.servo_controlled = -1; //turn servo control back to off
// //		game.digs_taken = game.digs_taken +1;
// //		game.digs_remaining = game.digs_remaining-1;
//         } else {
//         	triggers.servo_controlled = -1; //turn servo control back to off
// //		game.digs_taken = game.digs_taken +1;
// //		game.digs_remaining = game.digs_remaining-1;
//         }
//




//        send_serial_to_scoreboard;

          /*				while (triggers.servo_angle >
             triggers.peek_threshold){ if(triggers.servo_angle > 0 &&
             triggers.servo_angle < 90){ // Need to close door to go on

                                                          send_string("Door
             Still Open. Close to Go On");
                                                          //send_trimpot_val(triggers.servo_controlled,
             trimpot_servo_range());
                                                          //receive_trimpot_value();
                                                          //trimpot_servo_range();
                                                          }
                                                  }*/


        // Reset touchpad and servo
        /*
                                        triggers.servo_controlled = -1;  //
           Reset control flag send_string("\n\nTouchpad reset to -1\r\n");
                                        triggers.touchpad_pressed = -1; //turn
           touchpad flag to off
        */
    /*

    if(check_servo_choice(game.correct_servos, triggers.touchpad_pressed,
game.total_items_to_find) == 1){ game.items_found = game.items_found+1;
            game.items_left_to_find = game.items_left_to_find -1;
            game.digstouc_taken = game.digs_taken +1;
            game.digs_remaining = game.digs_remaining-1;
    } else {
            game.digs_taken = game.digs_taken +1;
            game.digs_remaining = game.digs_remaining-1;
    }
    send_serial_to_scoreboard;

    triggers.servo_controlled != -1 //turn servo control back to off
}



    if(game.items_left_to_find == 0 || game.digs_remaining == 0 ||
game.time_remaining == 0;){ game.game_over = 1;
    }
*/
}
  return 0;
}




gamestate.c



/*
 * gamestate.c
 *
 *  Created on: May 18, 2025
 *      Author: 163910
 */

#include "gamestate.h"


int check_servo_choice(int correct_servos[], int servo_choice, int total_servos){
	for(int i = 0; i < total_servos; i++){
		if(correct_servos[i] == servo_choice){
	return(1);
        }
    }
    return 0;  // No match found after checking all
}
